#!/usr/bin/python
#
# Athanasios Athanassiadis
# Created:   August 2012
# Modified:  September 2012 (added sphere capabilities)
#   
###########################
from __future__ import division
import os, sys, subprocess
import argparse
import numpy as np

# geometry stuff

polygons = { 0: 'sphere',
             4: 'tetrahedron',
             6: 'hexahedron',
             8: 'octahedron',
             12: 'dodecahedron',
             20: 'icosahedron'}

# conversion between different descriptive parameters for the polyhedra
# prefactors taken from wikipedia or calculated
# v - volume
# a - edge length (circle perim for sphere)
# r - circumradius

v2a = { 0: (lambda V: r2a[0]((V/4.11879)**(1/3))),
        4: (lambda V: (V * 8.48528)**(1/3)),
        6: (lambda V: V**(1/3)),
        8: (lambda V: (V / .471405)**(1/3)),
        12: (lambda V: (V / 7.6631190)**(1/3)),
        20: (lambda V: (V / 2.1816950)**(1/3)),
        }

a2r = { 0: (lambda a: a / (2 * np.pi)),
        4: (lambda a: .6123724 * a),
        6: (lambda a: .8660254 * a),
        8: (lambda a: .7071067 * a),
        12: (lambda a: 1.401259 * a),
        20: (lambda a: .9510575 * a),
        }

r2a = { 0: (lambda r: 2 * np.pi * r),
        4: (lambda r: r / .6123724),
        6: (lambda r: r / .8660254),
        8: (lambda r: r / .7071067),
        12: (lambda r: r / 1.401259),
        20: (lambda r: r / .9510575),
        }

a2v = { 0: (lambda a: 4.18879 * a2r[0](a)**3),
        4: (lambda a: a**3 / 8.48528),
        6: (lambda a: a**3),
        8: (lambda a: a**3 * .4714045),
        12: (lambda a: a**3 * 7.6631190),
        20: (lambda a: a**3 * 2.1816950),
        } 
            

if __name__ == "__main__":

    parser = argparse.ArgumentParser(\
        description="generate an openSCAD script to generate an array of polyhedra",\
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)


    NX0 = 10
    NY0 = 10
    NZ0 = 1
    DX0 = 1.5
    DY0 = 1.5
    DZ0 = 1.3
    R0 = 1

    parser.add_argument('poly', type=int, choices=polygons.keys(), help='polygon')
    parser.add_argument('-r', type=float, default=R0, help='polygon extremum radius (mm)')


    parser.add_argument('-s', type=int, nargs=3, default=[NX0,NY0,NZ0], help='array shape')
    parser.add_argument('-d', type=float, nargs=3, default=[DX0,DY0,DZ0], help='interparticle spacing')
    parser.add_argument('-v', type=float, default=0.0, help='desired particle volume in cm^3')
    parser.add_argument('-a', type=float, default=0.0, help='desired side length in mm')
    parser.add_argument('-q', type=int, default=100, help='quality of sphere')
    parser.add_argument('--cornellvol', action='store_true', help='match the cornell particle volume')
    parser.add_argument('--nums', action='store_true', help='just output lengths and volumes to outfile')
    parser.add_argument('outfile', type=str, help='outfile')
    
    args = parser.parse_args()
    p = args.poly
    polystr = polygons[p]
    r = args.r
    nx,ny,nz = args.s
    dx,dy,dz  = args.d
    v = args.v * 1000
    a = args.a
    q = args.q
    cornellv = args.cornellvol
    numsonly = args.nums
    outfile = args.outfile

    # volume specifier has precedence over edge length and radius

    print 'creating ' + polystr

    if cornellv:
        v = .0225 # mL
        v *= 1000
        print 'setting volume to v=%f mm^3' % v

    if v:
        a = v2a[p](v)
        print 'setting edge length to a=%f mm' % a

    if a:
        r = a2r[p](a)
        print 'setting circumscribed radius to r=%f' % r


    outfile_base = os.path.split(outfile)[-1]
    outfile_base = os.path.splitext(outfile_base)[0]

    genoutfile = os.path.join('scad', outfile_base + '.scad')
    stloutfile = os.path.join('STL', outfile_base + '.stl')

    if not a:
        a = r2a[p](r)
    if not v:
        v = a2v[p](a)


    sys.stdout.write('-'*30)
    sys.stdout.write('\n')
    sys.stdout.write('r (mm): %f\na (mm): %f\nv (mm^3): %f\n' % (r,a,v))
    sys.stdout.write('-'*30)
    sys.stdout.write('\n')

    if numsonly:
        with open(outfile, 'w') as oof:
            oof.write('r (mm): %f\na (mm): %f\nv (mm^3): %f\n' % (r,a,v))
        sys.exit(0)

    iterstr = ''
    k = 0
    for i in range(nx - (k%2)):
        for j in range(ny - (k%2)):
            for k in range(nz):
                iterstr += '[%6.6f,%6.6f,%6.6f],' % (i*dx*r + (dx * (k%2)), j*dy*r + (dx * (k%2)), k*dz*r)
    iterstr = iterstr[:-1]


    if p==0:
        call = 'sphere(r=rad, $fn=%d)' % q
        comment = 1
    else:
        call = 'display_polyhedron(poly)'
        comment = 0


    with open(genoutfile, 'w') as of:
        of.write('''// file autogenerated by platonicSTLgen
// author: thanasi athanassiadis (thanasi@uchicago.edu)
// script dated: august 25, 2012

include <../platonic.scad>

// units are mm

rad = %6.6f;

%s poly = %s(rad);

for(i = [ %s ])
{
    translate(i)
    %s;
}

module display_polyhedron(poly) 
{
polyhedron(points = poly[0], triangles = poly[1]);
}

''' % (r, '//' * comment, polystr, iterstr, call))


    print 'wrote '+genoutfile

    # openscad -o STL/octarray.stl generated/octahedronarray.scad
    subprocess.call(['openscad', '-o%s' % stloutfile, genoutfile])

    print 'wrote '+stloutfile
